{% extends "base.html" %}

{% block content %}
<!-- Importar WaveSurfer.js e o plugin Regions -->
<script src="https://unpkg.com/wavesurfer.js@5.2.0"></script>
<script src="https://unpkg.com/wavesurfer.js@5.2.0/dist/plugin/wavesurfer.regions.min.js"></script>
<div class="audio-editor">
    <h2>Pag 2 - Gravar áudio</h2>
    <div class="controls">
        <button id="recordButton">Start Recording</button>
        <button id="stopButton" disabled>Stop Recording</button>
    </div>
    <div id="waveform" style="margin-top: 20px;"></div>
    <div id="statusMessage" style="margin-top: 20px; color: green;"></div>
    <div class="audio-controls">
        <button id="cutButton" disabled>Apply Cut</button>
    </div>
</div>

<style>
    .audio-editor {
        text-align: center;
        margin-top: 20px;
    }
    .controls, .audio-controls {
        margin: 20px;
    }
    #waveform {
        border: 1px solid #ccc;
        height: 150px;
        width: 100%;
        margin: auto;
    }
</style>



<script>
    let audioContext;
    let mediaRecorder;
    let audioChunks = [];
    let wavesurfer;
    let mediaStream;
    let duration = 0;
    let startPoint = null;
    let endPoint = null;

    document.addEventListener("DOMContentLoaded", () => {
        const recordButton = document.getElementById("recordButton");
        const stopButton = document.getElementById("stopButton");
        const cutButton = document.getElementById("cutButton");
        const waveformContainer = document.getElementById("waveform");
        const statusMessage = document.getElementById("statusMessage");

        // Inicializar WaveSurfer com o plugin Regions
        wavesurfer = WaveSurfer.create({
            container: waveformContainer,
            waveColor: "blue",
            progressColor: "purple",
            cursorColor: "navy",
            height: 150,
            responsive: true,
            plugins: [
                WaveSurfer.regions.create({
                    regionsMinLength: 0.01,
                    regions: [
                        {
                            start: 0.2,
                            end: 0.5,
                            loop: false,
                            color: 'hsla(125, 100%, 15%, 0.5)'
                        }
                    ],
                    dragSelection: {
                        slop: 5
                    }
                })
            ]
        });


        // Iniciar gravação
        recordButton.addEventListener("click", async () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(mediaStream);

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                const blob = new Blob(audioChunks, { type: "audio/webm" });
                audioChunks = [];
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Carregar áudio no WaveSurfer
                wavesurfer.loadBlob(blob);

                // Mostrar mensagem quando a forma de onda estiver pronta
                wavesurfer.on("ready", () => {
                    duration = wavesurfer.getDuration();
                    cutButton.disabled = false;
                });
            };

            mediaRecorder.start();
            recordButton.disabled = true;
            stopButton.disabled = false;
        });

        // Parar gravação
        stopButton.addEventListener("click", () => {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            recordButton.disabled = false;
            stopButton.disabled = true;
        });

        // Marcar pontos ao clicar na forma de onda
        wavesurfer.on("click", (e) => {
            const currentTime = wavesurfer.getCurrentTime();

            if (startPoint === null) {
                // Definir ponto inicial
                startPoint = currentTime;
                wavesurfer.addRegion({
                    start: currentTime,
                    end: currentTime + 0.1,
                    color: "rgba(0, 255, 0, 0.5)"
                });
                alert(`Start point set at ${currentTime.toFixed(3)}s`);
            } else if (endPoint === null) {
                // Definir ponto final
                endPoint = currentTime;
                wavesurfer.addRegion({
                    start: startPoint,
                    end: currentTime,
                    color: "rgba(255, 0, 0, 0.5)"
                });
                alert(`End point set at ${currentTime.toFixed(3)}s`);
            } else {
                // Resetar pontos se ambos já estiverem definidos
                alert("Points reset. Set new start and end points.");
                startPoint = null;
                endPoint = null;
                wavesurfer.clearRegions();
            }
        });

        // Aplicar corte
        cutButton.addEventListener("click", async () => {
            if (startPoint === null || endPoint === null) {
                alert("Please mark both start and end points on the waveform.");
                return;
            }

            const originalBuffer = wavesurfer.backend.buffer;
            if (!originalBuffer) {
                alert("Audio buffer is not available.");
                return;
            }

            const sampleRate = originalBuffer.sampleRate;
            const startSample = Math.floor(startPoint * sampleRate);
            const endSample = Math.floor(endPoint * sampleRate);
            const cutSamples = endSample - startSample;

            if (cutSamples <= 0) {
                alert("Invalid cut points. Please ensure end point is after start point.");
                return;
            }

            // Criar um novo buffer para o trecho cortado
            const newBuffer = audioContext.createBuffer(
                originalBuffer.numberOfChannels,
                cutSamples,
                sampleRate
            );

            for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
                const channelData = originalBuffer.getChannelData(channel);
                const cutChannelData = newBuffer.getChannelData(channel);
                cutChannelData.set(channelData.subarray(startSample, endSample));
            }

            // Converter para WAV e iniciar download
            const wavBlob = bufferToWave(newBuffer);
            const url = URL.createObjectURL(wavBlob);

            const link = document.createElement("a");
            link.href = url;
            link.download = "cut_audio.wav";
            link.click();
        });

        // Função auxiliar para converter buffer em WAV
        function bufferToWave(buffer) {
            const length = buffer.length * buffer.numberOfChannels * 2 + 44;
            const result = new ArrayBuffer(length);
            const view = new DataView(result);

            writeWAVHeader(view, buffer);

            let offset = 44;
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const channelData = buffer.getChannelData(i);
                for (let sample of channelData) {
                    const value = Math.max(-1, Math.min(1, sample));
                    view.setInt16(offset, value < 0 ? value * 0x8000 : value * 0x7FFF, true);
                    offset += 2;
                }
            }

            return new Blob([result], { type: "audio/wav" });
        }

        function writeWAVHeader(view, buffer) {
            const sampleRate = buffer.sampleRate;
            const numChannels = buffer.numberOfChannels;
            const byteRate = sampleRate * numChannels * 2;

            view.setUint32(0, 0x46464952, false); // "RIFF"
            view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
            view.setUint32(8, 0x45564157, false); // "WAVE"
            view.setUint32(12, 0x20746d66, false); // "fmt "
            view.setUint32(16, 16, true); // Subchunk1Size
            view.setUint16(20, 1, true); // AudioFormat
            view.setUint16(22, numChannels, true); // NumChannels
            view.setUint32(24, sampleRate, true); // SampleRate
            view.setUint32(28, byteRate, true); // ByteRate
            view.setUint16(32, numChannels * 2, true); // BlockAlign
            view.setUint16(34, 16, true); // BitsPerSample
            view.setUint32(36, 0x61746164, false); // "data"
            view.setUint32(40, buffer.length * numChannels * 2, true);
        }
    });
</script>
{% endblock %}
